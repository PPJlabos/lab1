{"split":"2-0","session.current":["/generator/generator.py","/generator/ucitaj.py"],"session.open":{"/generator/ucitaj.py":{"scrollTop":0,"scrollLeft":0,"selection":{"start":{"row":44,"column":0},"end":{"row":44,"column":0}},"lastUse":1414279774823,"undo":[[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":89,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","                print _state_def","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","        direktive = []","#        line = line + 2","        try:","            while lines[line].strip() != \"}\":","                direktive.append(lines[line])","                print lines[line] + \" \",","                line = line + 1","        except IndexError:","            break","        automat[_state_def] = direktive","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":89,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","                ","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","        direktive = []","#        line = line + 2","        try:","            while lines[line].strip() != \"}\":","                direktive.append(lines[line])","                print lines[line] + \" \",","                line = line + 1","        except IndexError:","            break","        automat[_state_def] = direktive","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":89,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","                ","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","        direktive = []","#        line = line + 2","        try:","            while lines[line].strip() != \"}\":","                direktive.append(lines[line])","                print lines[line] + \" \",","                line = line + 1","        except IndexError:","            break","        automat[_state_def] = direktive","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":90,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","        direktive = []","#        line = line + 2","        try:","            while lines[line].strip() != \"}\":","                direktive.append(lines[line])","","                line = line + 1","        except IndexError:","            break","        automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def] ","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":90,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","        direktive = []","#        line = line + 2","        try:","            while lines[line].strip() != \"}\":","                direktive.append(lines[line])","","                line = line + 1","        except IndexError:","            break","        automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def] ","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":90,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","            direktive = []","#        line = line + 2","            try:","                while lines[line].strip() != \"}\":","                    direktive.append(lines[line])","","                    line = line + 1","            except IndexError:","                break","        automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":90,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","            direktive = []","#        line = line + 2","            try:","                while lines[line].strip() != \"}\":","                    direktive.append(lines[line])","","                    line = line + 1","            except IndexError:","                break","        automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":92,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                    except IndexError:","                        break","                    automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":92,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                    except IndexError:","                        break","                    automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":92,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                except IndexError:","                        break","                    automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":92,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                except IndexError:","                        break","                    automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":92,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                except IndexError:","                    break","                automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":92,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                except IndexError:","                    break","                automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":92,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                except IndexError:","                    break","        automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":92,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                except IndexError:","                    break","        automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":93,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                    automat[_state_def] = direktive","                except IndexError:","                    break","","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":93,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                    automat[_state_def] = direktive","                except IndexError:","                    break","","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":93,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":93,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":95,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":95,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":95,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":95,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":55,"column":0}},"lines":["","#### TODO:","#   [ ]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [ ]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [ ]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [ ]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#","#","#","","","def ucitajUlaz():","    inputs = []","    regex = {}","    final = ''","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","    print final","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in inputs:","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        if \"%X\" in line:","            stanja_lex_analizatora = line.split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        if \"%L\" in line:","            lex_jedinke = line.split(\"%L\")[1].strip().split(' ')","            break","        # spremi definicije regex izraza u dict regex","        regex[line.split(' ')[0]] = line.split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz()"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":55,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#### TODO:","#   [ ]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [ ]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [ ]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [ ]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#","#","#","","","def ucitajUlaz():","    inputs = []","    regex = {}","    final = ''","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","    print final","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in inputs:","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        if \"%X\" in line:","            stanja_lex_analizatora = line.split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        if \"%L\" in line:","            lex_jedinke = line.split(\"%L\")[1].strip().split(' ')","            break","        # spremi definicije regex izraza u dict regex","        regex[line.split(' ')[0]] = line.split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz()"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":57,"column":0}},"lines":["","#[ ] TODO:","#   [ ]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [ ]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [ ]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [ ]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","    print final","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        if \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        if \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz()"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":57,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [ ]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [ ]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [ ]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [ ]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","    print final","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        if \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        if \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz()"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":95,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":95,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":96,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\"_state_def + \":                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":96,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\"_state_def + \":                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":96,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\"+_state_def + \":                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":96,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\"+_state_def + \":                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":96,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\"+ _state_def + \":                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":96,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\"+ _state_def + \":                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":96,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def + \":\"                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":96,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def + \":\"                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":98,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def + \":\"","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":98,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def + \":\"","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":98,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":98,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":98,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":98,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":99,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = coutn","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":99,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = coutn","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":100,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    coun ","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = count_stanja + 1","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":100,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    coun ","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = count_stanja + 1","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":100,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    count_stanja = 0","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = count_stanja + 1","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","    print count_stanja","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":100,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    count_stanja = 0","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = count_stanja + 1","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","    print count_stanja","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":101,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    count_stanja = 0","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = count_stanja + 1","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","    print count_stanja","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","            break","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}]],"redo":[]},"/generator/generator.py":{"scrollTop":0,"scrollLeft":0,"selection":{"start":{"row":25,"column":32},"end":{"row":25,"column":32}},"lastUse":1414279764261,"undo":[[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":44},"end":{"row":30,"column":45}},"text":"("}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":45},"end":{"row":30,"column":46}},"text":")"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":45},"end":{"row":30,"column":46}},"text":"'"},{"action":"insertText","range":{"start":{"row":30,"column":46},"end":{"row":30,"column":47}},"text":"'"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":46},"end":{"row":30,"column":47}},"text":"\\"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":47},"end":{"row":30,"column":48}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":50},"end":{"row":30,"column":51}},"text":"["}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":51},"end":{"row":30,"column":52}},"text":"]"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":51},"end":{"row":30,"column":52}},"text":"2"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":52},"end":{"row":30,"column":53}},"text":":"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":54},"end":{"row":30,"column":55}},"text":":"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":55},"end":{"row":31,"column":0}},"text":"\r\n"},{"action":"insertText","range":{"start":{"row":31,"column":0},"end":{"row":31,"column":8}},"text":"        "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":20},"end":{"row":30,"column":0}},"text":"\r\n"},{"action":"insertText","range":{"start":{"row":30,"column":0},"end":{"row":30,"column":4}},"text":"    "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":8},"end":{"row":32,"column":9}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":9},"end":{"row":32,"column":10}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":10},"end":{"row":32,"column":11}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":11},"end":{"row":32,"column":12}},"text":"n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":12},"end":{"row":32,"column":13}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":13},"end":{"row":32,"column":14}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":14},"end":{"row":32,"column":15}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":15},"end":{"row":32,"column":16}},"text":"l"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":32,"column":15},"end":{"row":32,"column":16}},"text":"l"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":15},"end":{"row":32,"column":16}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":16},"end":{"row":32,"column":17}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":17},"end":{"row":32,"column":18}},"text":"v"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":18},"end":{"row":32,"column":19}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":19},"end":{"row":32,"column":20}},"text":"l"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":20},"end":{"row":32,"column":21}},"text":"o"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":29,"column":12},"end":{"row":29,"column":13}},"text":"i"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":12},"end":{"row":29,"column":13}},"text":"G"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":13},"end":{"row":29,"column":14}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"n"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":29,"column":13},"end":{"row":29,"column":14}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":13},"end":{"row":29,"column":14}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":4},"end":{"row":33,"column":5}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":5},"end":{"row":33,"column":6}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":6},"end":{"row":33,"column":7}},"text":"t"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":7},"end":{"row":33,"column":8}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":33,"column":7},"end":{"row":33,"column":8}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":7},"end":{"row":33,"column":8}},"text":"u"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":8},"end":{"row":33,"column":9}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":9},"end":{"row":33,"column":10}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":10},"end":{"row":33,"column":11}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":33,"column":2},"end":{"row":33,"column":11}},"text":"  return "}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":54,"column":4},"end":{"row":54,"column":15}},"text":"prijelazi ="}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":54,"column":4},"end":{"row":54,"column":5}},"text":" "}]}]],"redo":[]},"/literatura/UTR2014-LV-Zadatak1.pdf":{"scrollTop":0,"scrollLeft":0,"selection":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"lastUse":1414137154147,"undo":[],"redo":[]},"/ulaznaMetoda.py":{"scrollTop":0,"scrollLeft":0,"selection":{"start":{"row":18,"column":16},"end":{"row":18,"column":16}},"lastUse":1414137112415,"undo":[[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":13,"column":15},"end":{"row":13,"column":16}},"text":"\""}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":13,"column":24},"end":{"row":13,"column":25}},"text":"\""}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":13,"column":25},"end":{"row":14,"column":0}},"text":"\n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":0},"end":{"row":14,"column":4}},"text":"    "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":4},"end":{"row":14,"column":5}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":5},"end":{"row":14,"column":6}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":6},"end":{"row":14,"column":7}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":7},"end":{"row":14,"column":8}},"text":"n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":8},"end":{"row":14,"column":9}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":9},"end":{"row":14,"column":10}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":10},"end":{"row":14,"column":11}},"text":"h"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":11},"end":{"row":14,"column":12}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":12},"end":{"row":14,"column":13}},"text":"l"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":13},"end":{"row":14,"column":14}},"text":"l"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":13},"end":{"row":14,"column":14}},"text":"l"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":12},"end":{"row":14,"column":13}},"text":"l"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":11},"end":{"row":14,"column":12}},"text":"e"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":10},"end":{"row":14,"column":11}},"text":"h"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":10},"end":{"row":14,"column":11}},"text":"\""},{"action":"insertText","range":{"start":{"row":14,"column":11},"end":{"row":14,"column":12}},"text":"\""}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":11},"end":{"row":14,"column":12}},"text":"h"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":12},"end":{"row":14,"column":13}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":13},"end":{"row":14,"column":14}},"text":"l"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":14},"end":{"row":14,"column":15}},"text":"o"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":16},"end":{"row":14,"column":17}},"text":":"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":13,"column":25},"end":{"row":13,"column":26}},"text":":"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":11,"column":13},"end":{"row":12,"column":0}},"text":"\n"},{"action":"insertText","range":{"start":{"row":12,"column":0},"end":{"row":12,"column":4}},"text":"    "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":4},"end":{"row":12,"column":5}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":5},"end":{"row":12,"column":6}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":6},"end":{"row":12,"column":7}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":7},"end":{"row":12,"column":8}},"text":"n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":8},"end":{"row":12,"column":9}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":9},"end":{"row":12,"column":10}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":10},"end":{"row":12,"column":11}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":11},"end":{"row":12,"column":12}},"text":"c"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":12},"end":{"row":12,"column":13}},"text":"c"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":16,"column":5},"end":{"row":16,"column":6}},"text":"u"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":16,"column":5},"end":{"row":16,"column":6}},"text":"i"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":16,"column":4},"end":{"row":16,"column":15}},"text":"citajUlaz()"},{"action":"insertText","range":{"start":{"row":16,"column":4},"end":{"row":16,"column":15}},"text":"citajUlaz()"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":1}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":1},"end":{"row":0,"column":2}},"text":"m"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":2},"end":{"row":0,"column":3}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":3},"end":{"row":0,"column":4}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":4},"end":{"row":0,"column":5}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":5},"end":{"row":0,"column":6}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":6},"end":{"row":0,"column":7}},"text":"s"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":7},"end":{"row":0,"column":8}},"text":"y"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":8},"end":{"row":0,"column":9}},"text":"s"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":3},"end":{"row":0,"column":4}},"text":"o"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":0},"end":{"row":1,"column":1}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":1},"end":{"row":1,"column":2}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":2},"end":{"row":1,"column":3}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":3},"end":{"row":1,"column":4}},"text":"n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":4},"end":{"row":1,"column":5}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":5},"end":{"row":1,"column":6}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":6},"end":{"row":1,"column":7}},"text":"a"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":1,"column":6},"end":{"row":1,"column":7}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":6},"end":{"row":1,"column":7}},"text":"\""},{"action":"insertText","range":{"start":{"row":1,"column":7},"end":{"row":1,"column":8}},"text":"\""}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":7},"end":{"row":1,"column":8}},"text":"a"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":9},"end":{"row":2,"column":0}},"text":"\n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":2,"column":0},"end":{"row":3,"column":0}},"text":"\n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":3,"column":0},"end":{"row":4,"column":0}},"text":"\n"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":17,"column":18},"end":{"row":17,"column":19}},"text":"M"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":17,"column":18},"end":{"row":17,"column":19}},"text":"m"}]}]],"redo":[]}},"window":{"left":-4,"top":-4,"width":1448,"height":880}}
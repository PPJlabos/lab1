{"split":"2-0","session.current":["/generator/ucitaj.py","/generator/regex.py"],"session.open":{"/generator/ucitaj.py":{"scrollTop":1415,"scrollLeft":0,"selection":{"start":{"row":117,"column":0},"end":{"row":117,"column":0}},"lastUse":1414349013039,"undo":[[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":11},"end":{"row":132,"column":12}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":12},"end":{"row":132,"column":13}},"text":"o"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":13},"end":{"row":132,"column":14}},"text":"u"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":14},"end":{"row":132,"column":15}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":15},"end":{"row":132,"column":16}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":132,"column":15},"end":{"row":132,"column":16}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":15},"end":{"row":132,"column":16}},"text":"F"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":16},"end":{"row":132,"column":17}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":17},"end":{"row":132,"column":18}},"text":"l"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":18},"end":{"row":132,"column":19}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":19},"end":{"row":132,"column":20}},"text":"."}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":20},"end":{"row":132,"column":21}},"text":"w"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":21},"end":{"row":132,"column":22}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":22},"end":{"row":132,"column":23}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":23},"end":{"row":132,"column":24}},"text":"t"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":24},"end":{"row":132,"column":25}},"text":"e"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":25},"end":{"row":132,"column":26}},"text":"("}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":26},"end":{"row":132,"column":27}},"text":")"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":26},"end":{"row":132,"column":27}},"text":"\""},{"action":"insertText","range":{"start":{"row":132,"column":27},"end":{"row":132,"column":28}},"text":"\""}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":132,"column":27},"end":{"row":132,"column":28}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":11},"end":{"row":134,"column":12}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":12},"end":{"row":134,"column":13}},"text":"o"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":13},"end":{"row":134,"column":14}},"text":"u"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":14},"end":{"row":134,"column":15}},"text":"t"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":15},"end":{"row":134,"column":16}},"text":"."}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":16},"end":{"row":134,"column":17}},"text":"F"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":17},"end":{"row":134,"column":18}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":18},"end":{"row":134,"column":19}},"text":"l"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":19},"end":{"row":134,"column":20}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":20},"end":{"row":134,"column":21}},"text":"."}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":134,"column":20},"end":{"row":134,"column":21}},"text":"."}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":134,"column":19},"end":{"row":134,"column":20}},"text":"e"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":134,"column":18},"end":{"row":134,"column":19}},"text":"l"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":134,"column":17},"end":{"row":134,"column":18}},"text":"i"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":134,"column":16},"end":{"row":134,"column":17}},"text":"F"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":134,"column":15},"end":{"row":134,"column":16}},"text":"."}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":15},"end":{"row":134,"column":16}},"text":"F"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":16},"end":{"row":134,"column":17}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":17},"end":{"row":134,"column":18}},"text":"l"},{"action":"insertText","range":{"start":{"row":134,"column":18},"end":{"row":134,"column":19}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":19},"end":{"row":134,"column":20}},"text":"."}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":20},"end":{"row":134,"column":21}},"text":"w"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":21},"end":{"row":134,"column":22}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":22},"end":{"row":134,"column":23}},"text":"i"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":23},"end":{"row":134,"column":24}},"text":"t"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":24},"end":{"row":134,"column":25}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":25},"end":{"row":134,"column":26}},"text":"("}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":26},"end":{"row":134,"column":27}},"text":")"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":26},"end":{"row":134,"column":27}},"text":"\""},{"action":"insertText","range":{"start":{"row":134,"column":27},"end":{"row":134,"column":28}},"text":"\""}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":28},"end":{"row":134,"column":29}},"text":"\\"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":134,"column":28},"end":{"row":134,"column":29}},"text":"\\"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":27},"end":{"row":134,"column":28}},"text":"\\"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":134,"column":28},"end":{"row":134,"column":29}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":130,"column":60},"end":{"row":130,"column":61}},"text":"."}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":130,"column":61},"end":{"row":130,"column":62}},"text":"s"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":130,"column":62},"end":{"row":130,"column":63}},"text":"t"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":130,"column":63},"end":{"row":130,"column":64}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":130,"column":64},"end":{"row":130,"column":65}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":130,"column":65},"end":{"row":130,"column":66}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":130,"column":66},"end":{"row":130,"column":67}},"text":"("}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":130,"column":67},"end":{"row":130,"column":68}},"text":")"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":4},"end":{"row":121,"column":5}},"text":"o"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":5},"end":{"row":121,"column":6}},"text":"u"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":6},"end":{"row":121,"column":7}},"text":"t"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":7},"end":{"row":121,"column":8}},"text":"."}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":121,"column":7},"end":{"row":121,"column":8}},"text":"."}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":7},"end":{"row":121,"column":8}},"text":"f"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":121,"column":7},"end":{"row":121,"column":8}},"text":"f"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":7},"end":{"row":121,"column":8}},"text":"F"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":8},"end":{"row":121,"column":9}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":9},"end":{"row":121,"column":10}},"text":"l"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":10},"end":{"row":121,"column":11}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":11},"end":{"row":121,"column":12}},"text":"."}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":12},"end":{"row":121,"column":13}},"text":"w"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":13},"end":{"row":121,"column":14}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":14},"end":{"row":121,"column":15}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":15},"end":{"row":121,"column":16}},"text":"t"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":16},"end":{"row":121,"column":17}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":17},"end":{"row":121,"column":18}},"text":"("}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":18},"end":{"row":121,"column":19}},"text":")"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":18},"end":{"row":121,"column":19}},"text":"\""},{"action":"insertText","range":{"start":{"row":121,"column":19},"end":{"row":121,"column":20}},"text":"\""}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":19},"end":{"row":121,"column":20}},"text":"\\"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":20},"end":{"row":121,"column":21}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":19},"end":{"row":121,"column":20}},"text":"#"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":20},"end":{"row":121,"column":21}},"text":"#"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":21},"end":{"row":121,"column":22}},"text":"#"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":19},"end":{"row":121,"column":20}},"text":"\\"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":121,"column":20},"end":{"row":121,"column":21}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":158,"column":0},"end":{"row":158,"column":100}},"text":"  #     print \"###################################################################################\"#"},{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":158,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [*]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","import regex","from regex import *","","","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    count_stanja = 0","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = count_stanja + 1","                except IndexError:","                    break","    return stanja","                #print\"\\n\" +_state_def","                #printautomat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","    #printcount_stanja","","","","","","def ucitajUlaz(automat):","    inputs = []","    stanja = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    #printfinal ## debug print","    #parsiraj ulaznu datoteku","#    #printlen(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            stanja = generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","            break","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    return stanja","def dodaj_u_dict(_dict, key, value):","    states = []","    states.append(value)","    if str(key) in _dict.keys():","        states.extend(_dict[key])","    _dict[key] = states","    ","def zapisi_u_file(_dict_main, _dict_stanja):","    ","    outFile = open (\"izlazni.txt\", \"w\")","    for key in _dict_stanja.keys():","        outFile.write(key + \"|\")","        for stanje in automat_po_stanjima[key]:","            outFile.write(stanje.split(\",\")[0].split(\"(\")[1] + \",\")","        outFile.write(\" \")","    outFile.write(\"\\n\")","        ","    ","    for key in _dict_main.keys():","        outFile.write(key + ' ' + str(_dict_main[key]).replace(\"[\", \"\").replace(\"]\", \"\") + \"\\n\")","       ","    outFile.write(\"\\n###\\n\")","    for key in _dict_stanja.keys():","        for stanje in _dict_stanja[key]:","            try:","                #print stanje","                direktiva = stanje.split(\")\")[1]","                print direktiva","            except IndexError:","                pass","            outFile.write(stanje.split(\",\")[1].split(\")\")[0].strip())","            ","            outFile.write(\" \")","            outFile.write(direktiva.replace(\"[\" ,\"\").replace(\"]\", \"\").replace(\"'\", \"\"))","            outFile.write(\"\\n\")","                #print direkt","    ","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    regex_automat = {}","    regex_automat[brojac_stanja] = 0","    stanja = []","    stanja = ucitajUlaz(automat)","    automat_po_stanjima= {} ## za svako stanje pise pocetak i kraj automata","    for key in automat.keys():","        for stanje in stanja:","            if \"<\"+ stanje+\">\" in key:","                regexStanja = key.replace(\"<\"+stanje+\">\", \"\")","                dodaj_u_dict(automat_po_stanjima, stanje, str(pretvori(regexStanja, regex_automat)) + str(automat[key])) ## pretvori vraca pair prvo i zadnje stanje","            ","  #  for key in popis_pocetnihizavrsnih_stanja_automata.keys():","   #     print popis_pocetnihizavrsnih_stanja_automata[key]","    zapisi_u_file(regex_automat,automat_po_stanjima)","    ","  # for key in automat_po_stanjima.keys():","  #     print key","  #     for stanje in automat_po_stanjima[key]:","  #         print stanje.split(\")\")[1]"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":159,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [*]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","import regex","from regex import *","","","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    count_stanja = 0","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = count_stanja + 1","                except IndexError:","                    break","    return stanja","                #print\"\\n\" +_state_def","                #printautomat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","    #printcount_stanja","","","","","","def ucitajUlaz(automat):","    inputs = []","    stanja = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    #printfinal ## debug print","    #parsiraj ulaznu datoteku","#    #printlen(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            stanja = generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","            break","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    return stanja","def dodaj_u_dict(_dict, key, value):","    states = []","    states.append(value)","    if str(key) in _dict.keys():","        states.extend(_dict[key])","    _dict[key] = states","","def zapisi_u_file(_dict_main, _dict_stanja):","","    outFile = open (\"izlazni.txt\", \"w\")","    for key in _dict_stanja.keys():","        outFile.write(key + \"|\")","        for stanje in automat_po_stanjima[key]:","            outFile.write(stanje.split(\",\")[0].split(\"(\")[1] + \",\")","        outFile.write(\" \")","    outFile.write(\"\\n\")","","","    for key in _dict_main.keys():","        outFile.write(key + ' ' + str(_dict_main[key]).replace(\"[\", \"\").replace(\"]\", \"\") + \"\\n\")","","    outFile.write(\"\\n###\\n\")","    for key in _dict_stanja.keys():","        for stanje in _dict_stanja[key]:","            try:","                #print stanje","                direktiva = stanje.split(\")\")[1]","                print direktiva","            except IndexError:","                pass","            outFile.write(stanje.split(\",\")[1].split(\")\")[0].strip())","","            outFile.write(\" \")","            outFile.write(direktiva.replace(\"[\" ,\"\").replace(\"]\", \"\").replace(\"'\", \"\").replace(\",\",\"\"))","            outFile.write(\"\\n\")","                #print direkt","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    regex_automat = {}","    regex_automat[brojac_stanja] = 0","    stanja = []","    stanja = ucitajUlaz(automat)","    automat_po_stanjima= {} ## za svako stanje pise pocetak i kraj automata","    for key in automat.keys():","        for stanje in stanja:","            if \"<\"+ stanje+\">\" in key:","                regexStanja = key.replace(\"<\"+stanje+\">\", \"\")","                dodaj_u_dict(automat_po_stanjima, stanje, str(pretvori(regexStanja, regex_automat)) + str(automat[key])) ## pretvori vraca pair prvo i zadnje stanje","","  #  for key in popis_pocetnihizavrsnih_stanja_automata.keys():","   #     print popis_pocetnihizavrsnih_stanja_automata[key]","    zapisi_u_file(regex_automat,automat_po_stanjima)","","  # for key in automat_po_stanjima.keys():","  #     print key","  #     for stanje in automat_po_stanjima[key]:","  #         print stanje.split(\")\")[1]","  #     print \"###################################################################################\"#"]}]}]],"redo":[]},"/generator/regex.py":{"scrollTop":1485,"scrollLeft":0,"selection":{"start":{"row":127,"column":25},"end":{"row":127,"column":25}},"lastUse":1414335620979,"undo":[[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":157,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    if str(stanje1)+\"|\" in automat.keys():","        stanje2.append(automat[str(stanje1) + \"|\"])","    automat[str(stanje1)+\"|\"+znak] = stanje2","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":158,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    if str(stanje1)+\"|\" in automat.keys():","        stanje2.append(automat[str(stanje1) + \"|\"])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = stanje2","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":158,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    if str(stanje1)+\"|\" in automat.keys():","        stanje2.append(automat[str(stanje1) + \"|\"])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = stanje2","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":158,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    if str(stanje1)+\"|\"+znak in automat.keys():","        stanje2.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = stanje2","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":158,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    if str(stanje1)+\"|\"+znak in automat.keys():","        stanje2.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = stanje2","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":160,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    state.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        state.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = stanje2","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":160,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    state.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        state.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = stanje2","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":160,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    state.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = stanje2","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":160,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    state.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = stanje2","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":160,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":160,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":160,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.extend(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":160,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.extend(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":160,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":160,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":160,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b*\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":160,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b*\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":160,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"ab*\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":160,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"ab*\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":160,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"ab\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":160,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"ab\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":161,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    print pretvori(\"ab\", automat)","    for key in automat.keys():","        print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":161,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    print pretvori(\"ab\", automat)","    for key in automat.keys():","        print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":161,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(str(automat[str(stanje1) + \"|\" + znak]))","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    print pretvori(\"ab\", automat)","    for key in automat.keys():","        print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":161,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(str(automat[str(stanje1) + \"|\" + znak]))","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    print pretvori(\"ab\", automat)","    for key in automat.keys():","        print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":161,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(str(automat[str(stanje1) + \"|\" + znak]))","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    print pretvori(\"a|b*\", automat)","    for key in automat.keys():","        print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":161,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.append(str(automat[str(stanje1) + \"|\" + znak]))","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    print pretvori(\"a|b*\", automat)","    for key in automat.keys():","        print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":161,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.extend((automat[str(stanje1) + \"|\" + znak]))","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    print pretvori(\"a|b*\", automat)","    for key in automat.keys():","        print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":161,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.extend((automat[str(stanje1) + \"|\" + znak]))","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    print pretvori(\"a|b*\", automat)","    for key in automat.keys():","        print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":161,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.extend(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    print pretvori(\"a|b*\", automat)","    for key in automat.keys():","        print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":161,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.extend(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    print pretvori(\"a|b*\", automat)","    for key in automat.keys():","        print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":162,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.extend(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","            ","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    print pretvori(\"a|b*\", automat)","    for key in automat.keys():","        print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":89,"column":32},"end":{"row":89,"column":33}},"text":"k"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":89,"column":33},"end":{"row":89,"column":34}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":89,"column":34},"end":{"row":89,"column":35}},"text":"y"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":89,"column":32},"end":{"row":89,"column":35}},"text":"key"}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":162,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.extend(automat[str(stanje1) + \"|\" + znak])","        print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # print element + \"<-----------------    element\"","            print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                print \"i have it\"","                x=a","            ","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    print pretvori(\"a|b*\", automat)","    for key in automat.keys():","        print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":162,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa #print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.extend(automat[str(stanje1) + \"|\" + znak])","        #print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # #print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # #print element + \"<-----------------    element\"","            #print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            #print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                #print \"i have it\"","                x=a","","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                #print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                #print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    #print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    #print pretvori(\"a|b*\", automat)","    for key in automat.keys():","        #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":160,"column":30},"end":{"row":161,"column":0}},"text":"\r\n"},{"action":"insertText","range":{"start":{"row":161,"column":0},"end":{"row":161,"column":8}},"text":"        "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":161,"column":8},"end":{"row":161,"column":9}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":161,"column":9},"end":{"row":161,"column":10}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":161,"column":10},"end":{"row":161,"column":11}},"text":"s"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":161,"column":11},"end":{"row":161,"column":12}},"text":"s"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":161,"column":11},"end":{"row":161,"column":12}},"text":"s"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":161,"column":10},"end":{"row":161,"column":11}},"text":"s"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":161,"column":9},"end":{"row":161,"column":10}},"text":"a"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":161,"column":8},"end":{"row":161,"column":9}},"text":"p"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":163,"column":0},"end":{"row":163,"column":4}},"text":"    "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":163,"column":4},"end":{"row":163,"column":8}},"text":"    "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":163,"column":8},"end":{"row":163,"column":9}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":163,"column":9},"end":{"row":163,"column":10}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":163,"column":10},"end":{"row":163,"column":11}},"text":"s"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":163,"column":11},"end":{"row":163,"column":12}},"text":"s"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":163,"column":0},"end":{"row":163,"column":12}},"text":"        pass"},{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":163,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa #print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.extend(automat[str(stanje1) + \"|\" + znak])","        #print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # #print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # #print element + \"<-----------------    element\"","            #print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            #print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                #print \"i have it\"","                x=a","","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                #print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                #print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    #print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    #print pretvori(\"a|b*\", automat)","    for key in automat.keys():","        ","        #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":164,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa ##print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    states = []","    states.append(stanje2)","    if str(stanje1)+\"|\"+znak in automat.keys():","        states.extend(automat[str(stanje1) + \"|\" + znak])","        ##print \"here \"","    automat[str(stanje1)+\"|\"+znak] = states","","","def nadi_iducu_zagradu(izraz, i):","   # ##print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","","","def pretvori(izraz, automat):","","    ##print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    fin = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","","            pronadjen_barem_jedan_operator = True","            _a=i+1","        fin = i+1","    izbori.append(izraz[_a:fin])","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    if pronadjen_barem_jedan_operator:","        #==================^=======^===============^=========^==========^=====================","","","        for element in izbori:","           # ##print element + \"<-----------------    element\"","            ##print str(izbori) + \"<////////////////////////////////// izbori i fali zadnji clan izraza\"","            ##print element","            _temp = pretvori(element ,automat)","            # povezi nove automate s starim automatima","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        i=0","        while i < (len(izraz)):","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if izraz[i] == 't':","                    prijelazni_znak = '\\t' # oznaka za tabu u C-u","                elif izraz[i] == 'n':","                    prijelazni_znak = '\\n'","                elif izraz[i] == '_':","                    prijelazni_znak = ' '","                else:","                    prijelazni_znak = izraz[i]","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    dodaj_prijelaz(automat, a, b, prijelazni_znak)#, prijelazn_znak)","","","            else:","                if izraz[i] == \"\\\\\":","                    prefiksirano = True","                    continue","","                if izraz[i] != \"(\":","                    a = novo_stanje(automat)","                    b = novo_stanje(automat)","                    if izraz[i] == \"$\":","                        dodaj_prijelaz(automat, a, b, e)","                    else:","                        dodaj_prijelaz(automat, a, b, izraz[i])","                else:","                    j = nadi_iducu_zagradu(izraz, i)","                    _temp = pretvori( izraz[i+1:j-1], automat)","                    a = _temp[0]","                    b = _temp[1]","                    i = j","","","            if i+1 < (len(izraz)) and izraz[i+1] == '*':","                ##print \"i have it\"","                x=a","","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                ##print str(a) + ' ' + str(b) + \" \" + str(x) + \" \" + str(y)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i = i+1","                ##print automat","","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","            i += 1","        # end of while","","        dodaj_prijelaz(automat, zadnje_stanje, desno_stanje, e)","    ##print str(( lijevo_stanje, desno_stanje)) + \"<|||| tu smo\"","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","if __name__ == \"__main__\":","    ##print pretvori(\"a|b*\", automat)","    for key in automat.keys():","","        ##print str(key) + \":  ==>     \" + str(automat[key])","        pass"]}]}]],"redo":[]},"/generator/regexGen.py":{"scrollTop":0,"scrollLeft":0,"selection":{"start":{"row":12,"column":0},"end":{"row":12,"column":0}},"lastUse":1414335586820,"undo":[[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":4},"end":{"row":18,"column":5}},"text":"n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":5},"end":{"row":18,"column":6}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":6},"end":{"row":18,"column":7}},"text":"d"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":7},"end":{"row":18,"column":8}},"text":"i"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":8},"end":{"row":18,"column":9}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":18,"column":8},"end":{"row":18,"column":9}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":8},"end":{"row":18,"column":9}},"text":"="}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":18,"column":8},"end":{"row":18,"column":9}},"text":"="}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":8},"end":{"row":18,"column":9}},"text":"_"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":18,"column":4},"end":{"row":18,"column":9}},"text":"nadi_"},{"action":"insertText","range":{"start":{"row":18,"column":4},"end":{"row":18,"column":24}},"text":"nadi_iducu_zagradu()"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":23},"end":{"row":18,"column":24}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":24},"end":{"row":18,"column":25}},"text":"z"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":25},"end":{"row":18,"column":26}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":26},"end":{"row":18,"column":27}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":27},"end":{"row":18,"column":28}},"text":"z"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":28},"end":{"row":18,"column":29}},"text":","}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":29},"end":{"row":18,"column":30}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":30},"end":{"row":18,"column":31}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":31},"end":{"row":18,"column":32}},"text":"o"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":32},"end":{"row":18,"column":33}},"text":"z"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":33},"end":{"row":18,"column":34}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":34},"end":{"row":18,"column":35}},"text":"c"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":35},"end":{"row":18,"column":36}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":36},"end":{"row":18,"column":37}},"text":"a"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":18,"column":36},"end":{"row":18,"column":37}},"text":"a"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":18,"column":35},"end":{"row":18,"column":36}},"text":"i"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":35},"end":{"row":18,"column":36}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":36},"end":{"row":18,"column":37}},"text":"j"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":37},"end":{"row":18,"column":38}},"text":"a"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":39},"end":{"row":18,"column":40}},"text":":"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":40},"end":{"row":19,"column":0}},"text":"\n"},{"action":"insertText","range":{"start":{"row":19,"column":0},"end":{"row":19,"column":4}},"text":"    "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":4},"end":{"row":19,"column":5}},"text":"b"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":5},"end":{"row":19,"column":6}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":6},"end":{"row":19,"column":7}},"text":"+"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":19,"column":6},"end":{"row":19,"column":7}},"text":"+"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":6},"end":{"row":19,"column":7}},"text":"+"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":19,"column":6},"end":{"row":19,"column":7}},"text":"+"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":6},"end":{"row":19,"column":7}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":7},"end":{"row":19,"column":8}},"text":"="}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":8},"end":{"row":19,"column":9}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":9},"end":{"row":19,"column":10}},"text":"1"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":10},"end":{"row":20,"column":0}},"text":"\n"},{"action":"insertText","range":{"start":{"row":20,"column":0},"end":{"row":20,"column":4}},"text":"    "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":4},"end":{"row":20,"column":5}},"text":"f"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":5},"end":{"row":20,"column":6}},"text":"o"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":6},"end":{"row":20,"column":7}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":7},"end":{"row":20,"column":8}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":8},"end":{"row":20,"column":9}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":9},"end":{"row":20,"column":10}},"text":"z"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":20,"column":8},"end":{"row":20,"column":10}},"text":"iz"},{"action":"insertText","range":{"start":{"row":20,"column":8},"end":{"row":20,"column":13}},"text":"izraz"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":13},"end":{"row":20,"column":14}},"text":"["}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":14},"end":{"row":20,"column":15}},"text":"]"}]}]],"redo":[]},"/generator/generator.py":{"scrollTop":0,"scrollLeft":0,"selection":{"start":{"row":26,"column":17},"end":{"row":26,"column":17}},"lastUse":1414279764261,"undo":[[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":44},"end":{"row":30,"column":45}},"text":"("}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":45},"end":{"row":30,"column":46}},"text":")"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":45},"end":{"row":30,"column":46}},"text":"'"},{"action":"insertText","range":{"start":{"row":30,"column":46},"end":{"row":30,"column":47}},"text":"'"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":46},"end":{"row":30,"column":47}},"text":"\\"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":47},"end":{"row":30,"column":48}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":50},"end":{"row":30,"column":51}},"text":"["}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":51},"end":{"row":30,"column":52}},"text":"]"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":51},"end":{"row":30,"column":52}},"text":"2"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":52},"end":{"row":30,"column":53}},"text":":"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":54},"end":{"row":30,"column":55}},"text":":"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":55},"end":{"row":31,"column":0}},"text":"\r\n"},{"action":"insertText","range":{"start":{"row":31,"column":0},"end":{"row":31,"column":8}},"text":"        "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":20},"end":{"row":30,"column":0}},"text":"\r\n"},{"action":"insertText","range":{"start":{"row":30,"column":0},"end":{"row":30,"column":4}},"text":"    "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":8},"end":{"row":32,"column":9}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":9},"end":{"row":32,"column":10}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":10},"end":{"row":32,"column":11}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":11},"end":{"row":32,"column":12}},"text":"n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":12},"end":{"row":32,"column":13}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":13},"end":{"row":32,"column":14}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":14},"end":{"row":32,"column":15}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":15},"end":{"row":32,"column":16}},"text":"l"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":32,"column":15},"end":{"row":32,"column":16}},"text":"l"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":15},"end":{"row":32,"column":16}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":16},"end":{"row":32,"column":17}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":17},"end":{"row":32,"column":18}},"text":"v"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":18},"end":{"row":32,"column":19}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":19},"end":{"row":32,"column":20}},"text":"l"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":20},"end":{"row":32,"column":21}},"text":"o"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":29,"column":12},"end":{"row":29,"column":13}},"text":"i"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":12},"end":{"row":29,"column":13}},"text":"G"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":13},"end":{"row":29,"column":14}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"n"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":29,"column":13},"end":{"row":29,"column":14}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":13},"end":{"row":29,"column":14}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":4},"end":{"row":33,"column":5}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":5},"end":{"row":33,"column":6}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":6},"end":{"row":33,"column":7}},"text":"t"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":7},"end":{"row":33,"column":8}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":33,"column":7},"end":{"row":33,"column":8}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":7},"end":{"row":33,"column":8}},"text":"u"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":8},"end":{"row":33,"column":9}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":9},"end":{"row":33,"column":10}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":10},"end":{"row":33,"column":11}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":33,"column":2},"end":{"row":33,"column":11}},"text":"  return "}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":54,"column":4},"end":{"row":54,"column":15}},"text":"prijelazi ="}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":54,"column":4},"end":{"row":54,"column":5}},"text":" "}]}]],"redo":[]},"/literatura/UTR2014-LV-Zadatak1.pdf":{"scrollTop":0,"scrollLeft":0,"selection":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"lastUse":1414137154147,"undo":[],"redo":[]},"/ulaznaMetoda.py":{"scrollTop":0,"scrollLeft":0,"selection":{"start":{"row":18,"column":16},"end":{"row":18,"column":16}},"lastUse":1414137112415,"undo":[[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":13,"column":15},"end":{"row":13,"column":16}},"text":"\""}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":13,"column":24},"end":{"row":13,"column":25}},"text":"\""}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":13,"column":25},"end":{"row":14,"column":0}},"text":"\n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":0},"end":{"row":14,"column":4}},"text":"    "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":4},"end":{"row":14,"column":5}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":5},"end":{"row":14,"column":6}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":6},"end":{"row":14,"column":7}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":7},"end":{"row":14,"column":8}},"text":"n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":8},"end":{"row":14,"column":9}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":9},"end":{"row":14,"column":10}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":10},"end":{"row":14,"column":11}},"text":"h"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":11},"end":{"row":14,"column":12}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":12},"end":{"row":14,"column":13}},"text":"l"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":13},"end":{"row":14,"column":14}},"text":"l"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":13},"end":{"row":14,"column":14}},"text":"l"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":12},"end":{"row":14,"column":13}},"text":"l"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":11},"end":{"row":14,"column":12}},"text":"e"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":10},"end":{"row":14,"column":11}},"text":"h"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":10},"end":{"row":14,"column":11}},"text":"\""},{"action":"insertText","range":{"start":{"row":14,"column":11},"end":{"row":14,"column":12}},"text":"\""}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":11},"end":{"row":14,"column":12}},"text":"h"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":12},"end":{"row":14,"column":13}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":13},"end":{"row":14,"column":14}},"text":"l"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":14},"end":{"row":14,"column":15}},"text":"o"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":16},"end":{"row":14,"column":17}},"text":":"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":13,"column":25},"end":{"row":13,"column":26}},"text":":"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":11,"column":13},"end":{"row":12,"column":0}},"text":"\n"},{"action":"insertText","range":{"start":{"row":12,"column":0},"end":{"row":12,"column":4}},"text":"    "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":4},"end":{"row":12,"column":5}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":5},"end":{"row":12,"column":6}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":6},"end":{"row":12,"column":7}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":7},"end":{"row":12,"column":8}},"text":"n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":8},"end":{"row":12,"column":9}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":9},"end":{"row":12,"column":10}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":10},"end":{"row":12,"column":11}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":11},"end":{"row":12,"column":12}},"text":"c"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":12},"end":{"row":12,"column":13}},"text":"c"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":16,"column":5},"end":{"row":16,"column":6}},"text":"u"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":16,"column":5},"end":{"row":16,"column":6}},"text":"i"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":16,"column":4},"end":{"row":16,"column":15}},"text":"citajUlaz()"},{"action":"insertText","range":{"start":{"row":16,"column":4},"end":{"row":16,"column":15}},"text":"citajUlaz()"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":1}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":1},"end":{"row":0,"column":2}},"text":"m"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":2},"end":{"row":0,"column":3}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":3},"end":{"row":0,"column":4}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":4},"end":{"row":0,"column":5}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":5},"end":{"row":0,"column":6}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":6},"end":{"row":0,"column":7}},"text":"s"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":7},"end":{"row":0,"column":8}},"text":"y"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":8},"end":{"row":0,"column":9}},"text":"s"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":3},"end":{"row":0,"column":4}},"text":"o"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":0},"end":{"row":1,"column":1}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":1},"end":{"row":1,"column":2}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":2},"end":{"row":1,"column":3}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":3},"end":{"row":1,"column":4}},"text":"n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":4},"end":{"row":1,"column":5}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":5},"end":{"row":1,"column":6}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":6},"end":{"row":1,"column":7}},"text":"a"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":1,"column":6},"end":{"row":1,"column":7}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":6},"end":{"row":1,"column":7}},"text":"\""},{"action":"insertText","range":{"start":{"row":1,"column":7},"end":{"row":1,"column":8}},"text":"\""}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":7},"end":{"row":1,"column":8}},"text":"a"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":9},"end":{"row":2,"column":0}},"text":"\n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":2,"column":0},"end":{"row":3,"column":0}},"text":"\n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":3,"column":0},"end":{"row":4,"column":0}},"text":"\n"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":17,"column":18},"end":{"row":17,"column":19}},"text":"M"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":17,"column":18},"end":{"row":17,"column":19}},"text":"m"}]}]],"redo":[]}},"window":{"left":-4,"top":-4,"width":1448,"height":880}}
{"split":"2-0","session.current":["/generator/regexGen.py","/generator/regex.py"],"session.open":{"/generator/regex.py":{"scrollTop":549,"scrollLeft":0,"selection":{"start":{"row":85,"column":20},"end":{"row":85,"column":20}},"lastUse":1414335620979,"undo":[[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":62,"column":31},"end":{"row":62,"column":32}},"text":"^"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":62,"column":47},"end":{"row":62,"column":48}},"text":"^"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":62,"column":57},"end":{"row":62,"column":58}},"text":"^"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":62,"column":68},"end":{"row":62,"column":69}},"text":"^"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":62,"column":23},"end":{"row":62,"column":24}},"text":" "}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":62,"column":22},"end":{"row":62,"column":23}},"text":"^"}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":118,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[len(automat)+1] = \"\"","    return len(automat)","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":118,"column":0}},"lines":["def novo_stanje(automat):","    automat[len(automat)+1] = \"\"","    return len(automat)","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":118,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[len(automat)+1] = \"\"","    return len(automat)","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":118,"column":0}},"lines":["def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_ ","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":118,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_ ","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":118,"column":0}},"lines":["def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":118,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":119,"column":0}},"lines":["def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stnaja = 0","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":119,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stnaja = 0","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":119,"column":0}},"lines":["def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stnaja = 0","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, broj)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":119,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stnaja = 0","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, broj)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":119,"column":0}},"lines":["def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = 0","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":119,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = 0","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":119,"column":0}},"lines":["def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat, broj)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = 0","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":119,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat, broj)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = 0","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":119,"column":0}},"lines":["def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat, brojac)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = 0","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":119,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat, brojac)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = 0","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":119,"column":0}},"lines":["def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat, brojac_stanja)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat, brojac_stanja)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = 0","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":119,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(brojac_stanja):","    brojac_stanja += 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(brojac_stanja)","    desno_stanje = novo_stanje(brojac_stanja)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat, brojac_stanja)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat, brojac_stanja)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = 0","automat = {}","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":121,"column":0}},"lines":["def novo_stanje(automat):","    automat[broja]","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja =brojac_stanja","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":121,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[broja]","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja =brojac_stanja","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":121,"column":0}},"lines":["def novo_stanje(automat):","    automat[brojac_stanja] = automat","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja =brojac_stanja","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":121,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[brojac_stanja] = automat","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja =brojac_stanja","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":121,"column":0}},"lines":["def novo_stanje(automat):","    automat[brojac_stanja] = automat[]","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja =brojac_stanja","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":121,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[brojac_stanja] = automat[]","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja =brojac_stanja","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":121,"column":0}},"lines":["def novo_stanje(automat):","    automat[brojac_stanja] = automat[brojac_stanja] + 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja =brojac_stanja","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":121,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[brojac_stanja] = automat[brojac_stanja] + 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja =brojac_stanja","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":121,"column":0}},"lines":["def novo_stanje(automat):","    automat[brojac_stanja] = automat[brojac_stanja] + 1","    return brojac_stanja ","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja =brojac_stanja","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":121,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[brojac_stanja] = automat[brojac_stanja] + 1","    return brojac_stanja ","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja =brojac_stanja","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat, brojac_stanja)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":121,"column":0}},"lines":["def novo_stanje(automat):","    automat[brojac_stanja] = automat[brojac_stanja] + 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja =brojac_stanja","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":121,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[brojac_stanja] = automat[brojac_stanja] + 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja =brojac_stanja","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":121,"column":0}},"lines":["def novo_stanje(automat):","    automat[brojac_stanja] = automat[brojac_stanja] + 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":121,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[brojac_stanja] = automat[brojac_stanja] + 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat, brojac_stanja):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":121,"column":0}},"lines":["def novo_stanje(automat):","    automat[brojac_stanja] = automat[brojac_stanja] + 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":121,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[brojac_stanja] = automat[brojac_stanja] + 1","    return brojac_stanja","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":121,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":121,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    pass #print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":121,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":121,"column":0}},"nl":"\r\n","lines":["# kao neki brojac stanja u automatu","def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","   # print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":35}},"text":"# kao neki brojac stanja u automatu"},{"action":"insertText","range":{"start":{"row":0,"column":35},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":121,"column":0}},"lines":["def novo_stanje(automat):","    automat[\"brojac_stanja\"] = automat[\"brojac_stanja\"] + 1","    return automat[brojac_stanja]","","","","# prebroji koliko ima \\ u nizu prije znaka, ukoliko je broj paran (\\\\) onda je operator","# ukoliko je broj \\ neparan (\\) ona je znak, npr. \\( -> je oznaka za zagradu dok je ( operator selekcije u izrazu ()","# \\ se koristi kao escape oznaka, npr u C-u \\\\ -> znaci \\, \\n -> novi red \\t -> tab \\\" navodnik unutar stringa print (\"\\\"\") -> \"","def je_operator(izraz, i):","    br = 0","    while i-1 >= 0 and izraz[i-1]=='\\\\': # broji escape oznake, ukoliko se pojavi nesto sto nije \\ onda prekini provjeru","        br = br + 1","        i = i - 1       # gledamo unazad od znaka koji provjeravam","    return br%2 == 0    # ukoliko je broj znakova \\ paran onda je znak operator, inace je znak","","","","def dodaj_prijelaz(automat ,stanje1, stanje2, znak):","    automat[str(stanje1)+znak] = stanje2","","def nadi_iducu_zagradu(izraz, i):","   # print izraz","    br_zagrada = 1","    for j in range( len (izraz[i+1:])):","        if izraz[j] == \")\" and je_operator (izraz, j):","            br_zagrada -= 1","            if br_zagrada == 0:","                return j","        elif izraz[j] == \"(\" and je_operator(izraz, j):","            br_zagrada += 1","","    return i","","","","","","    # automat ce biti dict automat, ime dicta ce biti genericko i vezano uz stanje -> dict(stanje lex analizatora, dict automata)","def pretvori(izraz, automat):","    #print str(izraz) + \"  <=================   pretvori\"","    e = \"$\"","    izbori = []","    elementi = []","    br_zagrada = 0 # pobroji kolicinu zagrada zasto se broje zagrade i kako se pretvaraju","    _a = 0","    pronadjen_barem_jedan_operator = False","# ===============v==========v=============v==========radi=========v======v======v========","    for i in range(len(izraz)):","","        if izraz[i] == '(' and je_operator(izraz, i): # provjeri je li trenutni znak operator otvorena zagrada (","            br_zagrada += 1","","        elif izraz[i] == ')' and je_operator(izraz, i):  # provjeri je li trenutni znak operator zatvorena zagrada )","            br_zagrada -= 1","            # ako naidjes na izraz oblika (ab)|c razdvoji izraz na ['(ab)', 'c']","        elif br_zagrada == 0 and izraz[i] == '|' and je_operator(izraz, i):","            izbori.append(izraz[_a:i])","            print izraz[_a:i]","            pronadjen_barem_jedan_operator = True","            _a=i+1","# ===================^=======^===============^=========^==========^=====================","    lijevo_stanje = novo_stanje(automat)","    desno_stanje = novo_stanje(automat)","    print izbori","    if pronadjen_barem_jedan_operator:","        for element in izbori:","           # print element + \"<-----------------    element\"","            _temp = pretvori(element ,automat)","            #print _temp","            dodaj_prijelaz(automat, lijevo_stanje, _temp[0], e)","            dodaj_prijelaz(automat, _temp[1], desno_stanje, e)","    else:","        prefiksirano = False","        zadnje_stanje = lijevo_stanje","        for element in izraz:","","","            if prefiksirano:","                # slucaj 1","                prefiksirano = False","                if element == 't':","                    prijelazn_znak = '\\t' # oznaka za tabu u C-u","                elif element == 'n':","                    prijelazn_znak = '\\n'","                elif element == '_':","                    prijelazn_znak = ' '","                else:","                    prijelazn_znak = element","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, b, e)#, prijelazn_znak)","            else:","                # slucaj 2","                # TODO: pronadji odgovarajucu zatvorenu zagradu","                j = nadi_iducu_zagradu(izraz, i)","                _temp = pretvori( elementi , automat)","                a = _temp[0]","                b = _temp[1]","                i = j","            if i+1 < len(izraz) and izraz[i+1] == '*':","                y=b","                a = novo_stanje(automat)","                b = novo_stanje(automat)","                dodaj_prijelaz(automat, a, x, e)","                dodaj_prijelaz(automat, y, b, e)","                dodaj_prijelaz(automat, a, b, e)","                dodaj_prijelaz(automat, y, x, e)","                i += 1","            dodaj_prijelaz(automat, zadnje_stanje, a, e)","            zadnje_stanje = b","    return (lijevo_stanje, desno_stanje)","","brojac_stanja = \"brojac_stanja\"","","automat = {}","automat[brojac_stanja] = 0","print pretvori(\"a|b|(acs|S)e|\\\\t|w*\", automat)","for key in automat.keys():","    print str(key) + \":  ==>     \" + str(automat[key])"]}]}]],"redo":[]},"/generator/regexGen.py":{"scrollTop":0,"scrollLeft":0,"selection":{"start":{"row":20,"column":15},"end":{"row":20,"column":15}},"lastUse":1414335586820,"undo":[[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":4},"end":{"row":18,"column":5}},"text":"n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":5},"end":{"row":18,"column":6}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":6},"end":{"row":18,"column":7}},"text":"d"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":7},"end":{"row":18,"column":8}},"text":"i"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":8},"end":{"row":18,"column":9}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":18,"column":8},"end":{"row":18,"column":9}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":8},"end":{"row":18,"column":9}},"text":"="}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":18,"column":8},"end":{"row":18,"column":9}},"text":"="}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":8},"end":{"row":18,"column":9}},"text":"_"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":18,"column":4},"end":{"row":18,"column":9}},"text":"nadi_"},{"action":"insertText","range":{"start":{"row":18,"column":4},"end":{"row":18,"column":24}},"text":"nadi_iducu_zagradu()"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":23},"end":{"row":18,"column":24}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":24},"end":{"row":18,"column":25}},"text":"z"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":25},"end":{"row":18,"column":26}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":26},"end":{"row":18,"column":27}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":27},"end":{"row":18,"column":28}},"text":"z"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":28},"end":{"row":18,"column":29}},"text":","}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":29},"end":{"row":18,"column":30}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":30},"end":{"row":18,"column":31}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":31},"end":{"row":18,"column":32}},"text":"o"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":32},"end":{"row":18,"column":33}},"text":"z"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":33},"end":{"row":18,"column":34}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":34},"end":{"row":18,"column":35}},"text":"c"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":35},"end":{"row":18,"column":36}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":36},"end":{"row":18,"column":37}},"text":"a"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":18,"column":36},"end":{"row":18,"column":37}},"text":"a"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":18,"column":35},"end":{"row":18,"column":36}},"text":"i"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":35},"end":{"row":18,"column":36}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":36},"end":{"row":18,"column":37}},"text":"j"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":37},"end":{"row":18,"column":38}},"text":"a"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":39},"end":{"row":18,"column":40}},"text":":"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":18,"column":40},"end":{"row":19,"column":0}},"text":"\n"},{"action":"insertText","range":{"start":{"row":19,"column":0},"end":{"row":19,"column":4}},"text":"    "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":4},"end":{"row":19,"column":5}},"text":"b"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":5},"end":{"row":19,"column":6}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":6},"end":{"row":19,"column":7}},"text":"+"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":19,"column":6},"end":{"row":19,"column":7}},"text":"+"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":6},"end":{"row":19,"column":7}},"text":"+"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":19,"column":6},"end":{"row":19,"column":7}},"text":"+"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":6},"end":{"row":19,"column":7}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":7},"end":{"row":19,"column":8}},"text":"="}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":8},"end":{"row":19,"column":9}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":9},"end":{"row":19,"column":10}},"text":"1"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":19,"column":10},"end":{"row":20,"column":0}},"text":"\n"},{"action":"insertText","range":{"start":{"row":20,"column":0},"end":{"row":20,"column":4}},"text":"    "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":4},"end":{"row":20,"column":5}},"text":"f"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":5},"end":{"row":20,"column":6}},"text":"o"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":6},"end":{"row":20,"column":7}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":7},"end":{"row":20,"column":8}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":8},"end":{"row":20,"column":9}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":9},"end":{"row":20,"column":10}},"text":"z"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":20,"column":8},"end":{"row":20,"column":10}},"text":"iz"},{"action":"insertText","range":{"start":{"row":20,"column":8},"end":{"row":20,"column":13}},"text":"izraz"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":13},"end":{"row":20,"column":14}},"text":"["}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":20,"column":14},"end":{"row":20,"column":15}},"text":"]"}]}]],"redo":[]},"/generator/ucitaj.py":{"scrollTop":0,"scrollLeft":0,"selection":{"start":{"row":12,"column":0},"end":{"row":12,"column":0}},"lastUse":1414279774823,"undo":[[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":89,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","                print _state_def","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","        direktive = []","#        line = line + 2","        try:","            while lines[line].strip() != \"}\":","                direktive.append(lines[line])","                print lines[line] + \" \",","                line = line + 1","        except IndexError:","            break","        automat[_state_def] = direktive","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":89,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","                ","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","        direktive = []","#        line = line + 2","        try:","            while lines[line].strip() != \"}\":","                direktive.append(lines[line])","                print lines[line] + \" \",","                line = line + 1","        except IndexError:","            break","        automat[_state_def] = direktive","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":89,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","                ","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","        direktive = []","#        line = line + 2","        try:","            while lines[line].strip() != \"}\":","                direktive.append(lines[line])","                print lines[line] + \" \",","                line = line + 1","        except IndexError:","            break","        automat[_state_def] = direktive","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":90,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","        direktive = []","#        line = line + 2","        try:","            while lines[line].strip() != \"}\":","                direktive.append(lines[line])","","                line = line + 1","        except IndexError:","            break","        automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def] ","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":90,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","        direktive = []","#        line = line + 2","        try:","            while lines[line].strip() != \"}\":","                direktive.append(lines[line])","","                line = line + 1","        except IndexError:","            break","        automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def] ","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":90,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","            direktive = []","#        line = line + 2","            try:","                while lines[line].strip() != \"}\":","                    direktive.append(lines[line])","","                    line = line + 1","            except IndexError:","                break","        automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":90,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","            direktive = []","#        line = line + 2","            try:","                while lines[line].strip() != \"}\":","                    direktive.append(lines[line])","","                    line = line + 1","            except IndexError:","                break","        automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":92,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                    except IndexError:","                        break","                    automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":92,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                    except IndexError:","                        break","                    automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":92,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                except IndexError:","                        break","                    automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":92,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                except IndexError:","                        break","                    automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":92,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                except IndexError:","                    break","                automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":92,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                except IndexError:","                    break","                automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":92,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                except IndexError:","                    break","        automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":92,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                except IndexError:","                    break","        automat[_state_def] = direktive","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":93,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                    automat[_state_def] = direktive","                except IndexError:","                    break","","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":93,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                    automat[_state_def] = direktive","                except IndexError:","                    break","","        print _state_def + \":                       ###<-------------\"","        print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":93,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":93,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":95,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":95,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if stanje in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":95,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":95,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":55,"column":0}},"lines":["","#### TODO:","#   [ ]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [ ]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [ ]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [ ]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#","#","#","","","def ucitajUlaz():","    inputs = []","    regex = {}","    final = ''","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","    print final","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in inputs:","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        if \"%X\" in line:","            stanja_lex_analizatora = line.split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        if \"%L\" in line:","            lex_jedinke = line.split(\"%L\")[1].strip().split(' ')","            break","        # spremi definicije regex izraza u dict regex","        regex[line.split(' ')[0]] = line.split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz()"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":55,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#### TODO:","#   [ ]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [ ]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [ ]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [ ]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#","#","#","","","def ucitajUlaz():","    inputs = []","    regex = {}","    final = ''","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","    print final","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in inputs:","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        if \"%X\" in line:","            stanja_lex_analizatora = line.split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        if \"%L\" in line:","            lex_jedinke = line.split(\"%L\")[1].strip().split(' ')","            break","        # spremi definicije regex izraza u dict regex","        regex[line.split(' ')[0]] = line.split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz()"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":57,"column":0}},"lines":["","#[ ] TODO:","#   [ ]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [ ]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [ ]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [ ]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","    print final","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        if \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        if \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz()"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":57,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [ ]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [ ]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [ ]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [ ]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","    print final","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        if \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        if \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz()"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":95,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":95,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print _state_def + \":                       ###<-------------\"","                print automat[_state_def]","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":96,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\"_state_def + \":                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":96,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\"_state_def + \":                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":96,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\"+_state_def + \":                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":96,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\"+_state_def + \":                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":96,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\"+ _state_def + \":                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":96,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\"+ _state_def + \":                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":96,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def + \":\"                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":96,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def + \":\"                       ","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":98,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def + \":\"","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":98,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def + \":\"","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":98,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":98,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":98,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":98,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":99,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = coutn","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":99,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = coutn","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":100,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    coun ","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = count_stanja + 1","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":100,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    coun ","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = count_stanja + 1","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":100,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    count_stanja = 0","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = count_stanja + 1","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","    print count_stanja","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}],[{"group":"doc","deltas":[{"action":"removeLines","range":{"start":{"row":0,"column":0},"end":{"row":100,"column":0}},"nl":"\r\n","lines":["### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata","","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    count_stanja = 0","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = count_stanja + 1","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","    print count_stanja","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]},{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":78}},"text":"### regex je popis osnovnig skracenica regexa koja se slaze u ostatak automata"},{"action":"insertText","range":{"start":{"row":0,"column":78},"end":{"row":1,"column":0}},"text":"\r\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":101,"column":0}},"lines":["","#[ ] TODO:","#   [*]     Povezi ostatak izraza osnovnih regexa u ostatku datoteke","#   [*]     Stavi svaki izraz u datoteci u dict","#   [ ]     Generiraj automat stanja za svaki regex vezan u kljuc dicta","#   [*]     Generiraj popis automata prema glavnim stanjima","#   [ ]     Generiraj automat za zadani regex","#   [*]     Razdovji stanja u zasebne liste","#   [*]     Napravi popis glavnih stanja","#   [*]     Popis lex jedinki za koristenje u lex analizatoru","#   [ ]     Popis prihvatljivih stanja (f stanja)","","automat = {}","","","def generiraj_lex_automat(lines, current, automat, stanja, regex):","    _state_def = \"\"","    count_stanja = 0","    for line in range (current,len(lines)): # sa svaku liniju u definiciji jezika","","        for stanje in stanja:               # provjeri za sva stanja lexanalizatora u popisu stanja lexanalizatora","","            if \"<\"+stanje+\">\" in lines[line]:       # ako se odnosi na trenutno stanje","                _state_def = lines[line]","","                # TODO: treba preraditi spremi definiciju u dict stanja =>> krivo jer ce se prepisati definicija automata","                for key in regex.keys():        #dopuni nazive regexa s punim izrazom","                    if key in _state_def:","                        _state_def =  _state_def.replace(key, \"(\" + regex[key] + \")\") # dopuni ostatak regularnih izraza","","                direktive = []","#        line = line + 2","                try:","                    line = line + 2","                    while lines[line].strip() != \"}\":","                        direktive.append(lines[line])","","                        line = line + 1","","                    automat[_state_def] = direktive","                    count_stanja = count_stanja + 1","                except IndexError:","                    break","","                print \"\\n\" +_state_def","                print automat[_state_def]","","                # TODO: file regex.py sadrzi generator automata stanja za regularne izraze","                # TODO: povezi automate sa akcijama vezanim uz prihvacene regularne izraze","","    print count_stanja","","","","","def ucitajUlaz(automat):","    inputs = []","    regex = {}","    final = ''","    procitao_rex_jedinke = False","    # procitaj ulaznu datoteku definicije jezika, spremi svaki red kao novi clan liste inputs","    while True:","        try:","            inputs.append(raw_input())","        except EOFError:","            final = '\\n'.join(inputs)","            break","#    print final ## debug print","    #parsiraj ulaznu datoteku","#    print len(inputs)  ## debug print","    for line in range (len(inputs)):","        if procitao_rex_jedinke:","            # kada procita postavke jezika (lex jedinke, stanja lex automata i definicije reg izraza) napravi DKA glavnih stanja lex analizatora","            generiraj_lex_automat(inputs, line, automat, stanja_lex_analizatora, regex)","            break","        # spremi stanja lex analizatora u listu stanja_lex_analizatora","        elif \"%X\" in inputs[line]:","            stanja_lex_analizatora = inputs[line].split('%X')[1].strip().split(' ')","        # spremi oznake lex jedinki u listu lex_jedinke","        elif \"%L\" in inputs[line]:","            lex_jedinke = inputs[line].split(\"%L\")[1].strip().split(' ')","            procitao_rex_jedinke = True","        # spremi definicije regex izraza u dict regex","        else:","            regex[inputs[line].split(' ')[0]] = inputs[line].split(' ')[1]","","    # dopuni regularne izraze (zamjeni skracenice s punim regularnim izrazom)","    for key in regex.keys():","       for reg in regex.keys():","                if key in regex[reg]:","                    regex[reg] = regex[reg].replace(key, \"(\" + regex[key] + \")\")","","    print automat","","#    print lex_jedinke  ## debug print","#    print stanja_lex_analizatora   ## debug print","","# ako se samostalno ucitava file pokreni ucitajUlaz()","if __name__ == \"__main__\":","    ucitajUlaz(automat)"]}]}]],"redo":[]},"/generator/generator.py":{"scrollTop":0,"scrollLeft":0,"selection":{"start":{"row":26,"column":17},"end":{"row":26,"column":17}},"lastUse":1414279764261,"undo":[[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":44},"end":{"row":30,"column":45}},"text":"("}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":45},"end":{"row":30,"column":46}},"text":")"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":45},"end":{"row":30,"column":46}},"text":"'"},{"action":"insertText","range":{"start":{"row":30,"column":46},"end":{"row":30,"column":47}},"text":"'"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":46},"end":{"row":30,"column":47}},"text":"\\"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":47},"end":{"row":30,"column":48}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":50},"end":{"row":30,"column":51}},"text":"["}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":51},"end":{"row":30,"column":52}},"text":"]"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":51},"end":{"row":30,"column":52}},"text":"2"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":52},"end":{"row":30,"column":53}},"text":":"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":54},"end":{"row":30,"column":55}},"text":":"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":30,"column":55},"end":{"row":31,"column":0}},"text":"\r\n"},{"action":"insertText","range":{"start":{"row":31,"column":0},"end":{"row":31,"column":8}},"text":"        "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":20},"end":{"row":30,"column":0}},"text":"\r\n"},{"action":"insertText","range":{"start":{"row":30,"column":0},"end":{"row":30,"column":4}},"text":"    "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":8},"end":{"row":32,"column":9}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":9},"end":{"row":32,"column":10}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":10},"end":{"row":32,"column":11}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":11},"end":{"row":32,"column":12}},"text":"n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":12},"end":{"row":32,"column":13}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":13},"end":{"row":32,"column":14}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":14},"end":{"row":32,"column":15}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":15},"end":{"row":32,"column":16}},"text":"l"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":32,"column":15},"end":{"row":32,"column":16}},"text":"l"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":15},"end":{"row":32,"column":16}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":16},"end":{"row":32,"column":17}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":17},"end":{"row":32,"column":18}},"text":"v"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":18},"end":{"row":32,"column":19}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":19},"end":{"row":32,"column":20}},"text":"l"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":32,"column":20},"end":{"row":32,"column":21}},"text":"o"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":29,"column":12},"end":{"row":29,"column":13}},"text":"i"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":12},"end":{"row":29,"column":13}},"text":"G"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":13},"end":{"row":29,"column":14}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"n"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":29,"column":13},"end":{"row":29,"column":14}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":13},"end":{"row":29,"column":14}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":29,"column":14},"end":{"row":29,"column":15}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":4},"end":{"row":33,"column":5}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":5},"end":{"row":33,"column":6}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":6},"end":{"row":33,"column":7}},"text":"t"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":7},"end":{"row":33,"column":8}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":33,"column":7},"end":{"row":33,"column":8}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":7},"end":{"row":33,"column":8}},"text":"u"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":8},"end":{"row":33,"column":9}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":9},"end":{"row":33,"column":10}},"text":"n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":33,"column":10},"end":{"row":33,"column":11}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":33,"column":2},"end":{"row":33,"column":11}},"text":"  return "}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":54,"column":4},"end":{"row":54,"column":15}},"text":"prijelazi ="}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":54,"column":4},"end":{"row":54,"column":5}},"text":" "}]}]],"redo":[]},"/literatura/UTR2014-LV-Zadatak1.pdf":{"scrollTop":0,"scrollLeft":0,"selection":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"lastUse":1414137154147,"undo":[],"redo":[]},"/ulaznaMetoda.py":{"scrollTop":0,"scrollLeft":0,"selection":{"start":{"row":18,"column":16},"end":{"row":18,"column":16}},"lastUse":1414137112415,"undo":[[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":13,"column":15},"end":{"row":13,"column":16}},"text":"\""}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":13,"column":24},"end":{"row":13,"column":25}},"text":"\""}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":13,"column":25},"end":{"row":14,"column":0}},"text":"\n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":0},"end":{"row":14,"column":4}},"text":"    "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":4},"end":{"row":14,"column":5}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":5},"end":{"row":14,"column":6}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":6},"end":{"row":14,"column":7}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":7},"end":{"row":14,"column":8}},"text":"n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":8},"end":{"row":14,"column":9}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":9},"end":{"row":14,"column":10}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":10},"end":{"row":14,"column":11}},"text":"h"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":11},"end":{"row":14,"column":12}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":12},"end":{"row":14,"column":13}},"text":"l"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":13},"end":{"row":14,"column":14}},"text":"l"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":13},"end":{"row":14,"column":14}},"text":"l"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":12},"end":{"row":14,"column":13}},"text":"l"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":11},"end":{"row":14,"column":12}},"text":"e"}]},{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":10},"end":{"row":14,"column":11}},"text":"h"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":10},"end":{"row":14,"column":11}},"text":"\""},{"action":"insertText","range":{"start":{"row":14,"column":11},"end":{"row":14,"column":12}},"text":"\""}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":11},"end":{"row":14,"column":12}},"text":"h"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":12},"end":{"row":14,"column":13}},"text":"e"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":13},"end":{"row":14,"column":14}},"text":"l"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":14},"end":{"row":14,"column":15}},"text":"o"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":14,"column":16},"end":{"row":14,"column":17}},"text":":"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":13,"column":25},"end":{"row":13,"column":26}},"text":":"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":11,"column":13},"end":{"row":12,"column":0}},"text":"\n"},{"action":"insertText","range":{"start":{"row":12,"column":0},"end":{"row":12,"column":4}},"text":"    "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":4},"end":{"row":12,"column":5}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":5},"end":{"row":12,"column":6}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":6},"end":{"row":12,"column":7}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":7},"end":{"row":12,"column":8}},"text":"n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":8},"end":{"row":12,"column":9}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":9},"end":{"row":12,"column":10}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":10},"end":{"row":12,"column":11}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":11},"end":{"row":12,"column":12}},"text":"c"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":12,"column":12},"end":{"row":12,"column":13}},"text":"c"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":16,"column":5},"end":{"row":16,"column":6}},"text":"u"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":16,"column":5},"end":{"row":16,"column":6}},"text":"i"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":16,"column":4},"end":{"row":16,"column":15}},"text":"citajUlaz()"},{"action":"insertText","range":{"start":{"row":16,"column":4},"end":{"row":16,"column":15}},"text":"citajUlaz()"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":1}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":1},"end":{"row":0,"column":2}},"text":"m"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":2},"end":{"row":0,"column":3}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":3},"end":{"row":0,"column":4}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":4},"end":{"row":0,"column":5}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":5},"end":{"row":0,"column":6}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":6},"end":{"row":0,"column":7}},"text":"s"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":7},"end":{"row":0,"column":8}},"text":"y"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":8},"end":{"row":0,"column":9}},"text":"s"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":3},"end":{"row":0,"column":4}},"text":"o"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":0},"end":{"row":1,"column":1}},"text":"p"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":1},"end":{"row":1,"column":2}},"text":"r"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":2},"end":{"row":1,"column":3}},"text":"i"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":3},"end":{"row":1,"column":4}},"text":"n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":4},"end":{"row":1,"column":5}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":5},"end":{"row":1,"column":6}},"text":" "}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":6},"end":{"row":1,"column":7}},"text":"a"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":1,"column":6},"end":{"row":1,"column":7}},"text":"a"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":6},"end":{"row":1,"column":7}},"text":"\""},{"action":"insertText","range":{"start":{"row":1,"column":7},"end":{"row":1,"column":8}},"text":"\""}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":7},"end":{"row":1,"column":8}},"text":"a"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":1,"column":9},"end":{"row":2,"column":0}},"text":"\n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":2,"column":0},"end":{"row":3,"column":0}},"text":"\n"}]},{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":3,"column":0},"end":{"row":4,"column":0}},"text":"\n"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":17,"column":18},"end":{"row":17,"column":19}},"text":"M"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":17,"column":18},"end":{"row":17,"column":19}},"text":"m"}]}]],"redo":[]}},"window":{"left":-4,"top":-4,"width":1448,"height":880}}